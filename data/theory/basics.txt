findOptimalSolution(startState) -> 

		CubeNode startNode = new CubeNode(...);
		
		startNode.heuristic = maxHeuristic(...);

		CubeNode solution = IDAStar(startNode);
		
		return buildSolutionString(solution);
		
IDAStar(startNode) ->

		int heuristicMinimum = root.heuristic;

		CubeNode solution = null;
		
		while (solution == null) {

			solution = doSearch(...);

			// No solution found within the current minimum -- increase the depth of the search.
			heuristicMinimum += 1;
		}
		
		return solution;
		
doSearch(Node, PathCost, maxHeuristic) ->
		
		if (Node.state.isSolved()) 
			return toSearch;
			
		List<CubeNode> successors = generateSuccessors(toSearch);
		
		for (CubeNode successor : successors) {

			// Calculate the f cost for this node.
			int estimatedCost = pathcost + successor.heuristic;

			// If the estimated f cost is below the current minimum...
			if (estimatedCost <= currentMin) { // Try this path...

				// Travel-down the cheapest path searching for the goal state.
				CubeNode solution = doSearch(successor, pathcost + 1, currentMin);

				// Check if the goal state was found.
				if (solution != null) {
					return solution;
				}
			}
		}

		// No solution was found down this path so back the search up...
		return null;
			
				
generateSuccessors(Node)  ->
		List<CubeNode> successors = new ArrayList<CubeNode>(); // To store the successors
		RubiksCube dummyCube = null;
		int heuristic = 0;
		
		for( every possible rotation 15 )
			//if (root.getRotation == currentRotaion && root.face = currentFace) continue;
			
			dummyCube = root.getCube.rotate()
			
			heuristic = maxHeuristic(dummyCube)
			successors.add(new Node(root, dummyCube, rotation, heuristic)
		
		return successors;
	


maxHeuristic(Cube)  ->

		

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
